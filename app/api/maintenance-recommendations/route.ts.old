import { NextRequest, NextResponse } from 'next/server'
import { Pool } from 'pg'

const pool = new Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://shopops:shopops_dev@localhost:5432/shopops3',
})

const VEHICLE_DATABASES_API_KEY = process.env.VEHICLE_DATABASES_API_KEY

export async function POST(request: NextRequest) {
  const { year, make, model, mileage, vin } = await request.json()

  console.log(`[AI Maintenance] Lookup: ${year} ${make} ${model} (VIN: ${vin}) @ ${mileage} miles`)

  // ========== STEP 1: Check local database ==========
  try {
    const dbResult = await pool.query(`
      SELECT 
        service_name,
        mileage_interval,
        service_category,
        service_description,
        driving_condition
      FROM maintenance_schedules
      WHERE year = $1 
        AND LOWER(make) = LOWER($2)
        AND LOWER(model) = LOWER($3)
        AND mileage_interval <= $4
      ORDER BY mileage_interval DESC
      LIMIT 20
    `, [year, make, model, mileage])

    if (dbResult.rows.length > 0) {
      console.log(`[AI Maintenance] ✓ Found ${dbResult.rows.length} services in database`)
      return NextResponse.json({
        source: 'database',
        services: dbResult.rows,
        message: `Found ${dbResult.rows.length} services in database`
      })
    }

    console.log('[AI Maintenance] ✗ Not in database, trying Vehicle Databases API...')
  } catch (dbError) {
    console.error('[AI Maintenance] Database error:', dbError)
  }

  // ========== STEP 2: Try Vehicle Databases API ==========
  if (VEHICLE_DATABASES_API_KEY && vin) {
    try {
      const vdbUrl = `https://api.vehicledatabases.com/owner-manual/${vin}`
      console.log('[AI Maintenance] Calling Vehicle Databases API:', vdbUrl)
      
      const vdbResponse = await fetch(vdbUrl, {
        method: 'GET',
        headers: {
          'x-AuthKey': VEHICLE_DATABASES_API_KEY,
        },
        signal: AbortSignal.timeout(10000) // 10 second timeout
      })

      console.log('[AI Maintenance] Vehicle Databases API response status:', vdbResponse.status)
      
      if (vdbResponse.ok) {
        const vdbData = await vdbResponse.json()
        console.log('[AI Maintenance] Vehicle Databases API data:', JSON.stringify(vdbData).substring(0, 500))
        
        const manualUrl = vdbData.data?.path || vdbData.manual_url
        
        if (manualUrl) {
          console.log(`[AI Maintenance] ✓ Found manual in Vehicle Databases API: ${manualUrl}`)
          
          // Extract maintenance data with Gemini
          const services = await extractMaintenanceFromPDF(
            manualUrl, 
            year, 
            make, 
            model, 
            mileage
          )

          // Save to database for future lookups
          if (services.length > 0) {
            await saveServicesToDatabase(services, year, make, model, manualUrl)
            console.log(`[AI Maintenance] ✓ Saved ${services.length} services to database`)
          }

          return NextResponse.json({
            source: 'vehicle_databases_api',
            services,
            manual_url: manualUrl,
            message: 'Extracted from API manual - Saved to database'
          })
        } else {
          console.log('[AI Maintenance] API response missing manual path')
        }
      }
    } catch (apiError) {
      console.error('[AI Maintenance] Vehicle Databases API error:', apiError)
    }
  }

  console.log('[AI Maintenance] ✗ Not found in API')

  // ========== STEP 3: Return not found ==========
  return NextResponse.json({
    source: 'not_found',
    services: [],
    message: 'No maintenance data available for this vehicle. Try uploading the owner\'s manual.'
  })
}

// Helper: Extract maintenance from PDF using Gemini
async function extractMaintenanceFromPDF(
  pdfUrl: string, 
  year: number, 
  make: string, 
  model: string, 
  mileage: number
) {
  const { GoogleGenerativeAI } = require('@google/generative-ai')
  
  if (!process.env.GOOGLE_AI_API_KEY) {
    console.error('[AI Maintenance] No Gemini API key configured')
    return []
  }

  const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY)
  const geminiModel = genAI.getGenerativeModel({ model: 'gemini-3-flash-preview' })

  try {
    console.log('[AI Maintenance] Downloading PDF from:', pdfUrl)
    
    // Download PDF
    const pdfResponse = await fetch(pdfUrl, {
      signal: AbortSignal.timeout(30000) // 30 second timeout
    })
    
    if (!pdfResponse.ok) {
      throw new Error(`PDF download failed: ${pdfResponse.status}`)
    }
    
    const pdfBuffer = await pdfResponse.arrayBuffer()
    const base64Pdf = Buffer.from(pdfBuffer).toString('base64')

    console.log('[AI Maintenance] Extracting with Gemini...')

    const prompt = `
You are analyzing an automotive owner's manual PDF for maintenance recommendations.

Vehicle: ${year} ${make} ${model}
Current mileage: ${mileage} miles

Extract ALL maintenance services that are due at or before ${mileage} miles.

Look for the "Maintenance Schedule" or "Service Intervals" section.

Return JSON array with ONLY services that are due:
[
  {
    "service_name": "Engine oil change",
    "mileage_interval": 10000,
    "service_category": "oil_change",
    "service_description": "Replace engine oil and filter",
    "driving_condition": "normal"
  }
]

Service categories: oil_change, tire_service, brake_service, filter_replacement,
fluid_service, inspection, battery_service, spark_plugs, belts_hoses,
transmission_service, other

Include BOTH normal and severe driving schedules if present.

Return ONLY valid JSON array. No markdown. No explanation.
`

    const result = await geminiModel.generateContent([
      { text: prompt },
      {
        inlineData: {
          mimeType: 'application/pdf',
          data: base64Pdf
        }
      }
    ])

    const response = await result.response
    const text = response.text()
    
    console.log('[AI Maintenance] Gemini response received')
    
    try {
      const cleanText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim()
      const services = JSON.parse(cleanText)
      
      if (!Array.isArray(services)) {
        console.error('[AI Maintenance] Gemini returned non-array:', typeof services)
        return []
      }
      
      console.log(`[AI Maintenance] ✓ Extracted ${services.length} services`)
      return services
    } catch (parseError) {
      console.error('[AI Maintenance] Failed to parse Gemini response:', parseError)
      console.error('[AI Maintenance] Response text:', text.substring(0, 500))
      return []
    }
  } catch (error) {
    console.error('[AI Maintenance] Extraction error:', error)
    return []
  }
}

// Helper: Save services to database
async function saveServicesToDatabase(
  services: any[], 
  year: number, 
  make: string, 
  model: string,
  source_pdf: string
) {
  for (const service of services) {
    try {
      await pool.query(`
        INSERT INTO maintenance_schedules (
          year, make, model, 
          mileage_interval, service_name, service_description,
          service_category, driving_condition, source_pdf
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        ON CONFLICT (year, make, model, mileage_interval, service_name, driving_condition, engine_displacement)
        DO NOTHING
      `, [
        year, make, model,
        service.mileage_interval || 0,
        service.service_name,
        service.service_description,
        service.service_category,
        service.driving_condition || 'normal',
        source_pdf
      ])
    } catch (error) {
      console.error('[AI Maintenance] Error saving service:', service.service_name, error)
    }
  }
}
